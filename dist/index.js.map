{"version":3,"sources":["../src/index.ts","../src/actions/ActionGetNewsData.ts","../node_modules/uuid/dist/esm/stringify.js","../node_modules/uuid/dist/esm/rng.js","../node_modules/uuid/dist/esm/native.js","../node_modules/uuid/dist/esm/v4.js","../src/services/ApiService.ts","../src/actions/ActionGetOnChainData.ts","../src/actions/ActionProcessNews.ts","../src/actions/ActionProcessPrice.ts","../src/actions/ActionReply.ts","../src/actions/ActionMakeTrade.ts"],"sourcesContent":["import {\n  type Action,\n  type Content,\n  type GenerateTextParams,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type Provider,\n  type ProviderResult,\n  Service,\n  type State,\n  type Plugin,\n  logger,\n  parseKeyValueXml,\n  createUniqueUuid,\n  asUUID,\n  parseJSONObjectFromText,\n  MemoryType,\n} from '@elizaos/core';\n\nimport { z } from 'zod';\nimport { getNewsData } from \"./actions/ActionGetNewsData.ts\";\nimport { getOnChainData } from \"./actions/ActionGetOnChainData.ts\";\nimport { processNewsData } from \"./actions/ActionProcessNews.ts\";\nimport { processPriceData } from \"./actions/ActionProcessPrice.ts\";\nimport { reply } from \"./actions/ActionReply.ts\" ;\nimport { ApiService } from './services/ApiService.ts';\nimport { ActionEventPayload, composePromptFromState, EventType, messageHandlerTemplate, \n  MessagePayload, MessageReceivedHandlerParams, PluginEvents } from '@elizaos/core';\n\n\nimport { v4 } from 'uuid';\nimport { makeTrade } from './actions/ActionMakeTrade.ts';\n// import {getOnChainData} from \"./actions/action_get_on_chain_data\" ;\n/**\n * Defines the configuration schema for a plugin, including the validation rules for the plugin name.\n *\n * @type {import('zod').ZodObject<{ EXAMPLE_PLUGIN_VARIABLE: import('zod').ZodString }>}\n */\nconst configSchema = z.object({\n  EXAMPLE_PLUGIN_VARIABLE: z\n    .string()\n    .min(1, 'Example plugin variable is not provided')\n    .optional()\n    .transform((val) => {\n      if (!val) {\n        logger.warn('Example plugin variable is not provided (this is expected)');\n      }\n      return val;\n    }),\n});\n\n/**\n * Example HelloWorld action\n * This demonstrates the simplest possible action structure\n */\n/**\n * Action representing a hello world message.\n * @typedef {Object} Action\n * @property {string} name - The name of the action.\n * @property {string[]} similes - An array of related actions.\n * @property {string} description - A brief description of the action.\n * @property {Function} validate - Asynchronous function to validate the action.\n * @property {Function} handler - Asynchronous function to handle the action and generate a response.\n * @property {Object[]} examples - An array of example inputs and expected outputs for the action.\n */\nconst helloWorldAction: Action = {\n  name: 'HELLO_WORLD',\n  similes: ['GREET', 'SAY_HELLO'],\n  description: 'Responds with a simple hello world message',\n\n  validate: async (_runtime: IAgentRuntime, _message: Memory, _state: State): Promise<boolean> => {\n    // Always valid\n    return true;\n  },\n\n  handler: async (\n    _runtime: IAgentRuntime,\n    message: Memory,\n    _state: State,\n    _options: any,\n    callback: HandlerCallback,\n    _responses: Memory[]\n  ) => {\n    try {\n      logger.info('Handling HELLO_WORLD action');\n\n      // Simple response content\n      const responseContent: Content = {\n        text: 'hello world!',\n        actions: ['HELLO_WORLD'],\n        source: message.content.source,\n      };\n\n      // Call back with the hello world message\n      await callback(responseContent);\n\n      return responseContent;\n    } catch (error) {\n      logger.error('Error in HELLO_WORLD action:', error);\n      throw error;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Can you say hello?',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'hello world!',\n          actions: ['HELLO_WORLD'],\n        },\n      },\n    ],\n  ],\n};\n\n/**\n * Example Hello World Provider\n * This demonstrates the simplest possible provider implementation\n */\nconst helloWorldProvider: Provider = {\n  name: 'HELLO_WORLD_PROVIDER',\n  description: 'A simple example provider',\n\n  get: async (\n    _runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State\n  ): Promise<ProviderResult> => {\n    return {\n      text: 'I am a provider',\n      values: {},\n      data: {},\n    };\n  },\n};\n\nexport class StarterService extends Service {\n  static serviceType = 'starter';\n  capabilityDescription =\n    'This is a starter service which is attached to the agent through the starter plugin.';\n  constructor(runtime: IAgentRuntime) {\n    super(runtime);\n  }\n\n  static async start(runtime: IAgentRuntime) {\n    logger.info(`*** Starting starter service - MODIFIED: ${new Date().toISOString()} ***`);\n    const service = new StarterService(runtime);\n    return service;\n  }\n\n  static async stop(runtime: IAgentRuntime) {\n    logger.info('*** TESTING DEV MODE - STOP MESSAGE CHANGED! ***');\n    // get the service from the runtime\n    const service = runtime.getService(StarterService.serviceType);\n    if (!service) {\n      throw new Error('Starter service not found');\n    }\n    service.stop();\n  }\n\n  async stop() {\n    logger.info('*** THIRD CHANGE - TESTING FILE WATCHING! ***');\n  }\n}\n\n\nconst managerMsgHandler = async ({\n  runtime,\n  message,\n  callback,\n  onComplete,\n}: MessageReceivedHandlerParams): Promise<void> => {\n  let _state = await runtime.composeState(message);\n  const _responseContent = {\n      thought: '',\n      actions: [\"GET_PRICE\", \"GET_NEWS\", \"PROCESS_PRICE\", \"PROCESS_NEWS\", \"MAKE_TRADE\", \"REPLY\"],\n      text: ''\n    };\n  const _responseMessage = {\n        id: asUUID(v4()),\n        entityId: runtime.agentId,\n        agentId: runtime.agentId,\n        content: _responseContent,\n        roomId: message.roomId,\n        createdAt: Date.now(),\n      };\n  if (_responseContent && _responseContent.text && (_responseContent.actions?.length === 0 || \n    _responseContent.actions?.length === 1 && _responseContent.actions[0].toUpperCase() === \"REPLY\")) {\n    logger.warn('[Manager Handler] callback');\n    await callback(_responseContent);\n  } else {\n    logger.warn('[Manager Handler] processActions');\n    await runtime.processActions(message, [_responseMessage], _state, callback);\n  }\n  // return;\n  const manageTemplate_Intro = `\n  # You are a professional cryptoCurrency trader. If you received message from user, you should start you actions immediately. You are supposed to make a trade by executing actions in the following steps: 1.\"GET_PRICE\" and \"GET_NEWS\" (these two actions should be take together, not single); 2.\"PROCESS_PRICE\" and \"PROCESS_NEW \" (these two actions should be take together, not single); 3.\"MAKE_TRADE\"; 4.\"REPLY\".\\n\\n\n  # Task: Generate dialog with actions.\n  # Instructions: Write the next message for user.\n  \"thought\" should be a short description of what the agent is thinking about and planning.\n  \"message\" should be the next message for user which they will send to the conversation.\n  \"actions\" should be the next actions that agent will conduct, \"actions\" should include one or more actions. \n  # Possible response actions: \"GET_PRICE\", \"GET_NEWS\", \"PROCESS_PRICE\", \"PROCESS_NEWS\", \"MAKE_TRADE\", \"REPLY\", \"IGNORE\"\\n\\n\n  `;\n  const manageTemplate_Example = `\n  # Action Examples:\n  user: Please help me to make a decision of BTC trade, am I supposed to buy or sell?\\nagent: I'll conduct a research of BTC now. (actions: \"GET_PRICE\", \"GET_NEWS\")\\n\\n\n  agent: I've got the price and news of BTC, analysing. (actions: \"PROCESS_PRICE\", \"PROCESS_NEWS\")\\n\\n\n  agent: Analysis done, the price of BTC seems to be going down, we should sell part of them, about 20%. (actions: \"MAKE_TRADE\")\\n\\n\n  agent: Finally, reply the decision to user. The decision is: -0.2/1.0 of your BTC. (actions: \"REPLY\")\n  `;\n  const manageTemplate_Rules = `\n  # RULES:\n  RULE 1: User is asking the proposal to make a cryptoCurrency trade, you should begin to make a trade by executing actions in the following order above, and reply in the end;\\n\n  RULE 2: When your are executing ations, they must be executed strictly in the order of steps;\\n\n  RULE 3: You should decide next actions with the state of the steps'execution provided below, after actions in step before has been \"DONE\", execute actions in the next step;\\n\n  RULE 4: User is talking about other things, or your are executing actions (eg: In step 2, \"PROCESS_PRICE\" done, but still waiting \"PROCESS_NEWS\"), set \"actions\" as \"IGNORE\".\\n\n  RULE 5: The response must contain \"thought\", \"message\", and \"actions\".\\n\\n\n  `;\n  const manageTemplate_state = `\n  The state of the steps'execution:\n  `;\n  const manageTemplate_format = `\n  # Response format\n  # Response format should be formatted in a valid JSON block like this:\n\n  {\n      \"thought\": \"<string>\",\n      \"message\": \"<string>\",\n      \"actions\": [\"<string>\", \"<string>\", \"<string>\"]\n  }\n\n  # Your response should include the valid JSON block and nothing else.\n  # Response format end\n  `;\n  const manageTemplate_take_actions = `\n  # Choose your next actions within the [Possible response action] and the [RULES] mentioned before.\n  # Your response should be formatted in a valid JSON block like this:\n\n  {\n      \"thought\": \"<string>\",\n      \"message\": \"<string>\",\n      \"actions\": [\"<string>\", \"<string>\", \"<string>\"]\n  }\n  # Now, choose your next actions:\n  `;\n  // First, save the incoming message\n  logger.warn('[Manager Handler] Saving message to memory and embeddings');\n  if(message && message.content && message.content.text){\n    await Promise.all([\n      runtime.addEmbeddingToMemory(message),\n      runtime.createMemory(message, 'messages'),\n    ]);\n  }\n  let state = await runtime.composeState(message);\n  var apiService = runtime.getService(ApiService.serviceType) as ApiService;\n  var userMsgTmp = '';\n  var prompt = '';\n  // Message from CryptoTrade Actions, take next actions\n  if(message && message.content && message.content.text.startsWith('CryptoTrade_Action')){\n    prompt = composePromptFromState({\n        state,\n        template: manageTemplate_Intro + manageTemplate_Example + \n        manageTemplate_Rules + manageTemplate_state + apiService.getState() + \n        '\\n\\n' + manageTemplate_take_actions\n    });\n  }else{\n    // Message from user or system\n    if(message && message.content && message.content.text){\n      userMsgTmp = '\\n# User\\'s message as below:\\n\\nuser:' + message.content.text + '\\n# User\\'s message end';\n    }\n    prompt = composePromptFromState({\n        state,\n        template: manageTemplate_Intro + manageTemplate_Example + \n        manageTemplate_Rules + manageTemplate_state + apiService.getState() + \n        '\\n\\n' + userMsgTmp + manageTemplate_format\n    });\n  }\n\n  logger.warn('[CryptoTrader] *** prompt content ***\\n', prompt);\n  const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n    prompt: prompt,\n  });\n\n  // Attempt to parse the XML response\n  logger.warn('[CryptoTrader] *** response ***\\n', response);\n  // const parsedXml = parseKeyValueXml(response);\n  // const parsedJson = parseJSONObjectFromText(response);\n  const parsedJson = JSON.parse(response);\n  // logger.warn('[CryptoTrader] *** Parsed JSON Content ***\\n', parsedJson);\n\n  let responseContent: Content | null = null;\n  let responseMessages: Memory[] = [];\n  \n  // Map parsed XML to Content type, handling potential missing fields\n  // if (parsedXml) {\n  //   responseContent = {\n  //     ...parsedXml,\n  //     thought: parsedXml.thought || '',\n  //     actions: parsedXml.actions || ['IGNORE'],\n  //     providers: parsedXml.providers || [],\n  //     text: parsedXml.text || '',\n  //     simple: parsedXml.simple || false,\n  //   };\n  // } else {\n  //   responseContent = null;\n  // }\n  \n  logger.warn('[CryptoTrader] *** message.id ***\\n', message.id);\n  if (parsedJson) {\n    responseContent = {\n      ...parsedJson,\n      thought: parsedJson.thought || '',\n      actions: parsedJson.actions || ['IGNORE'],\n      text: parsedJson.text || ''\n    };\n  } else {\n    responseContent = null;\n  }\n  // logger.warn('[CryptoTrader] *** responseContent ***\\n', responseContent);\n  if (responseContent && message.id) {\n      responseContent.inReplyTo = createUniqueUuid(runtime, message.id);\n\n      const responseMessage = {\n        id: asUUID(v4()),\n        entityId: runtime.agentId,\n        agentId: runtime.agentId,\n        content: responseContent,\n        roomId: message.roomId,\n        createdAt: Date.now(),\n      };\n      \n      responseMessages = [responseMessage];\n  }\n  if (\n          responseContent &&\n          responseContent.text &&\n          (responseContent.actions?.length === 0 ||\n            (responseContent.actions?.length === 1 &&\n              responseContent.actions[0].toUpperCase() === 'REPLY'))\n        ) {\n          await callback(responseContent);\n        } else {\n          // this will process GET_DATA/NEWS ....\n          await runtime.processActions(message, responseMessages, state, callback);\n        }\n  }\n\nconst messageReceivedHandler = async ({\n  runtime,\n  message,\n  callback,\n  onComplete,\n}: MessageReceivedHandlerParams): Promise<void> => {\n  // Emit run started event\n  const startTime = Date.now();\n  await runtime.emitEvent(EventType.RUN_STARTED, {\n    runtime,\n    messageId: message.id,\n    roomId: message.roomId,\n    entityId: message.entityId,\n    startTime,\n    status: 'started',\n    source: 'messageHandler',\n  });\n\n  // First, save the incoming message\n  logger.debug('[Bootstrap] Saving message to memory and embeddings');\n  await Promise.all([\n    runtime.addEmbeddingToMemory(message),\n    runtime.createMemory(message, 'messages'),\n  ]);\n  let state = await runtime.composeState(message);\n  const prompt = composePromptFromState({\n    state,\n    template: runtime.character.templates?.messageHandlerTemplate || messageHandlerTemplate,\n  });\n\n  await runtime.emitEvent(EventType.MESSAGE_SENT, {\n    runtime,\n    messageId: message.id,\n    roomId: message.roomId,\n    entityId: message.entityId,\n    startTime,\n    status: 'started',\n    source: 'messageHandler',\n  });\n\n\n}\n\nvar events:PluginEvents = {\n  [EventType.MESSAGE_RECEIVED]: [\n    async (payload: MessagePayload) => {\n      if (!payload.callback) {\n        logger.warn('No callback provided for message');\n        return;\n      }\n      // logger.warn('payload.runtime.character.name: [' + payload.runtime.character.name + ']');\n      await managerMsgHandler({\n        runtime: payload.runtime,\n        message: payload.message,\n        callback: payload.callback,\n        onComplete: payload.onComplete\n      });\n    },\n  ],\n\n  [EventType.MESSAGE_SENT]: [\n    async (payload: MessagePayload) => {\n      logger.warn(`[CryptoTrader] Message sent: ${payload.message}`);\n      // if(payload.source && payload.source.startsWith('CryptoTrade_Action')){\n      //   await managerMsgHandler({\n      //     runtime: payload.runtime,\n      //     message: payload.message,\n      //     callback: payload.callback,\n      //     onComplete: payload.onComplete,\n      //   });\n      // }\n    },\n  ],\n\n  [EventType.ACTION_STARTED]: [\n    async (payload: ActionEventPayload) => {\n      logger.warn(`[Bootstrap] Action started: ${payload.actionName} (${payload.actionId})`);\n    },\n  ],\n\n  [EventType.ACTION_COMPLETED]: [\n    async (payload: ActionEventPayload) => {\n      const status = payload.error ? `failed: ${payload.error.message}` : 'completed';\n      logger.warn(`[Bootstrap] Action ${status}: ${payload.actionName} (${payload.actionId})`);\n    },\n  ]\n};\n\nexport const starterPlugin: Plugin = {\n  name: 'plugin-exam',\n  description: 'Plugin starter for elizaOS',\n  config: {\n    EXAMPLE_PLUGIN_VARIABLE: process.env.EXAMPLE_PLUGIN_VARIABLE,\n  },\n  async init(config: Record<string, string>) {\n    logger.info('*** TESTING DEV MODE - PLUGIN MODIFIED AND RELOADED! ***');\n    try {\n      const validatedConfig = await configSchema.parseAsync(config);\n\n      // Set all environment variables at once\n      for (const [key, value] of Object.entries(validatedConfig)) {\n        if (value) process.env[key] = value;\n      }\n      \n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        throw new Error(\n          `Invalid plugin configuration: ${error.errors.map((e) => e.message).join(', ')}`\n        );\n      }\n      throw error;\n    }\n  },\n  models: {\n    [ModelType.TEXT_SMALL]: async (\n      _runtime,\n      params,\n    ) => {\n       // Maybe you check the prompt and route to different models\n      // if (params.prompt.includes('code')) {\n      //   return await callCodeSpecializedModel(params);\n      // } else if (params.prompt.includes('creative')) {\n      //   return await callCreativeModel(params);\n      // } else {\n      //   return await callGeneralModel(params);\n      // }\n      return 'Crypto Plugin ModelType.TEXT_SMALL called...';\n    },\n    [ModelType.TEXT_LARGE]: async (\n      _runtime,\n      {\n        prompt,\n        stopSequences = [],\n        maxTokens = 8192,\n        temperature = 0.7,\n        frequencyPenalty = 0.7,\n        presencePenalty = 0.7,\n      }: GenerateTextParams\n    ) => {\n      return 'Crypto Plugin ModelType.TEXT_LARGE called......';\n    },\n  },\n  routes: [\n    {\n      name: 'hello-world-route',\n      path: '/helloworld',\n      type: 'GET',\n      handler: async (_req: any, res: any) => {\n        // send a response\n        res.json({\n          message: 'Hello World!',\n        });\n      },\n    },\n  ],\n  services: [StarterService, ApiService],\n  actions: [helloWorldAction, reply, getNewsData, \n    getOnChainData, processNewsData, processPriceData, makeTrade],\n  providers: [helloWorldProvider],\n  events:events\n};\n\nexport default starterPlugin;\n","import {\n    type ActionExample,\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State, \n    type Action,\n    MessageMemory,\n    EventType,\n    logger,\n    asUUID,\n} from \"@elizaos/core\";\n// import {CRYPTO_EventType} from '../index.ts'\nimport {v4} from 'uuid';\nimport { ApiService } from \"src/services/ApiService\";\nexport const getNewsData: Action = {\n    name: \"GET_NEWS\",\n    similes: [\n        \"CHECK_NEWS\",\n        \"FETCH_NEWS\",\n        \"GET_CRYPTO_NEWS\",\n        \"CRYPTO_NEWS\",\n        \"CHECK_CRYPTO_NEWS\"\n    ],\n    description: \"Get news for a cryptocurrency\",\n    validate: async (runtime: IAgentRuntime, message: MessageMemory, state: State) => {\n        // return (state['stage'] && state['stage']=='GET_DATA');\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state:State,\n        _options:{[key:string]:unknown},\n        callback: HandlerCallback,\n        _responses: Memory[]\n    ): Promise<boolean> => {\n        try {\n            // var result = getBlockchainPriceRequestSchema.safeParse(message.content);\n            // if (!result.success) {\n            //     throw new ValidationError(result.error.message);\n            // }\n            // var data = getBlockchainPriceRequestSchema.parse(message.content);\n            // // Ensure the content has the required shape\n            // const content = {\n            //     symbol: data.blockchain.toString().toUpperCase().trim(),\n            // };\n            // if (content.symbol.length < 2 || content.symbol.length > 10) {\n            //     throw new Error(\"Invalid cryptocurrency symbol\");\n            // }\n            const service = runtime.getService(ApiService.serviceType) as ApiService;\n            // const resp = await service.postNewsAPI(data.blockchain, data.date);\n            const resp = '{title:[Devs accuse colleagues from Bitcoin Core of being rogue over the plans to remove the spam filter from Bitcoin], context:[Bitcoin Core will remove OP_RETURN in the next version, scheduled for release in October. OP_RETURN is a script Bitcoin Core devs added to Bitcoin in 2014. It’s worth noting that Bitcoin Core developers have encouraged bitcoiners not to use the Bitcoin blockchain for recording arbitrary data, as there are better options that would not pile extra pressure on the Bitcoin network. At the end of the day, both currencies lost to the original Bitcoin. Will Bitcoin Core’s implementation turn Bitcoin into something different? Will learn by the end of the year.]}';\n            service.data['NEWS'] = resp;\n            if(callback){\n                callback({\n                    text:`\n                    Here is the off-chain news: \n                    \n                    ${resp}\n                    `\n                });\n                        \n                // await runtime.emitEvent(CRYPTO_EventType.CRYPTO_NOTIFY_ACTION_END, {\n                //     runtime,\n                //     entityId: runtime.agentId,\n                //     status: 'CRYPTO_NOTIFY_ACTION_END',\n                //     source: runtime.character.name,\n                // });\n                // state['stage']='NOTIFY_MANAGER';\n                \n                service.state['GET_NEWS'] = 'DONE';\n                var message: Memory;\n                message.content.text = 'CryptoTrade_Action_GET_NEWS DONE';\n                message.id = asUUID(v4());\n                runtime.emitEvent(EventType.MESSAGE_SENT, {runtime: runtime, message:message, source: 'CryptoTrade_Action_GET_NEWS'});\n                logger.warn('***** ACTION GET_NEWS DONE *****')\n                return true;\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error in news fetch:\", error);\n            if(callback){\n                callback({\n                    text:`\n                    Error in news fetch:\n                    \n                    ${error.message}\n                    `\n                });\n                return false;\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                name: \"{{user1}}\",\n                content: {\n                    text: \"What's the news of Bitcoin yesterday?\",\n                },\n            },\n            {\n                name: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the Bitcoin news for you right away.\",\n                    action: \"GET_NEWS\",\n                },\n            },\n            {\n                name: \"{{agent}}\",\n                content: {\n                    text: \"The news of  BTC market price are: [{date:{date}, title:{tiles1}, context:{context1}},.....]\",\n                },\n            },\n        ],\n        [\n            {\n                name: \"{{user1}}\",\n                content: {\n                    text: \"Can you check news of ETH on 2025/04/03?\",\n                },\n            },\n            {\n                name: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the news of Ethereum on 2025/04/03 for you.\",\n                    action: \"GET_NEWS\",\n                },\n            },\n            {\n                name: \"{{agent}}\",\n                content: {\n                    text: \"The news of ETH price on 2025/04/03 are: [{date:{date}, title:{tiles1}, context:{context1}},.....]\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import { randomFillSync } from 'crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n","import { randomUUID } from 'crypto';\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || rng)();\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import {\n    type IAgentRuntime,\n    logger,\n    Service,\n    State\n} from \"@elizaos/core\";\n\nvar data = JSON.stringify({\n      username: \"jane-doe\",\n      email: \"jane.doe@your-domain.com\",\n      role: \"superuser\",\n      age: 23,\n      birthplace: \"New York\",\n    })\n\n\nexport async function getData(path: string) : Promise<any>{\n  await fetch('http://127.0.0.1:8642/' + path)\n    .then(response => {return response.json();})\n    .then(_data => {\n      console.log(_data);\n      return _data;\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n}\n\nexport async function postData(path: string, data: any): Promise<any>{\n  var options:RequestInit = {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: data\n  };\n  await fetch('http://127.0.0.1:8642/' + path, options)\n    .then(response => {\n      return response.json();\n    })\n    .then(_data => {\n      console.log(_data);\n      return _data;\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n}\n\nexport class ApiService extends Service {\n  static serviceType = 'apiservice';\n  capabilityDescription =\n    'This is a api service which is attached to the agent through the cryptotrade plugin.';\n  constructor(runtime: IAgentRuntime) {\n    super(runtime);\n  }\n  static async start(runtime: IAgentRuntime) {\n    logger.info(`*** Starting api service - MODIFIED: ${new Date().toISOString()} ***`);\n    const service = new ApiService(runtime);\n    service.initState();\n    service.initData();\n    return service;\n  }\n\n  static async stop(runtime: IAgentRuntime) {\n    logger.info('*** TESTING DEV MODE - STOP MESSAGE CHANGED! ***');\n    // get the service from the runtime\n    const service = runtime.getService(ApiService.serviceType);\n    if (!service) {\n      throw new Error('API service not found');\n    }\n    service.stop();\n  }\n  \n  async stop() {\n    logger.info('*** THIRD CHANGE - TESTING FILE WATCHING! ***');\n  }\n  \n  async postOnChianAPI(_chain: string, _date: string){\n    // CALL SERVER\n    try {\n        const response = await postData('getOnChainData', {chain: _chain, date: _date});\n        return response.data;\n    } catch (error) {\n        console.error(\"CryptoTrade Server Error: \", error.message);\n        throw error;\n    }\n  }\n  async postNewsAPI(_chain: string, _date: string){\n        try {\n        const response = await postData('getNewsData', {chain: _chain, date: _date});\n        return response.data;\n    } catch (error) {\n        console.error(\"CryptoTrade Server Error: \", error.message);\n        throw error;\n    }\n  }\n  public state:{} = {Executing:false, GET_PRICE:'UNDONE'};\n  public data:{} = {STEP:0, STAGE:0};\n  public record:{} = {};\n  initState() {\n    this.state['Executing'] = false;\n    this.state['GET_PRICE'] = 'UNDONE';\n    this.state['GET_NEWS'] = 'UNDONE';\n    this.state['PROCESS_PRICE'] = 'UNDONE';\n    this.state['PROCESS_NEWS'] = 'UNDONE';\n    this.state['PROCESS_REFLET'] = 'UNDONE';\n    this.state['MAKE_TRADE'] = 'UNDONE';\n  }\n  initData() {\n    this.data['STEP'] = this.data['STEP'] + 1;\n    this.data['STAGE'] = 0;\n    this.data['PRICE'] = '';\n    this.data['NEWS'] = '';\n    this.data['ANALYSIS_PRICE'] = '';\n    this.data['ANALYSIS_NEWS'] = '';\n    this.data['REFLECT'] = '';\n    this.data['TRADE'] = '';\n  }\n  public stepEnd(){\n    this.record[data['STEP']] = {data: this.data, state: this.state};\n    logger.error('STEP END, RECORD:\\n', JSON.stringify(this.record[data['STEP']]))\n    this.initData();\n    this.initState();\n  }\n  public updateState(Executing: boolean, GET_PRICE: string, GET_NEWS: string, \n    PROCESS_PRICE: string, PROCESS_NEWS: string, PROCESS_REFLET: string, MAKE_TRADE: string) {\n    this.state['Executing'] = Executing;\n    this.state['GET_PRICE'] = GET_PRICE;\n    this.state['GET_NEWS'] = GET_NEWS;\n    this.state['PROCESS_PRICE'] = PROCESS_PRICE;\n    this.state['PROCESS_NEWS'] = PROCESS_NEWS;\n    this.state['PROCESS_REFLET'] = PROCESS_REFLET;\n    this.state['MAKE_TRADE'] = MAKE_TRADE;\n  }\n  public getState() {\n    return JSON.stringify({\n      Executing :this.state['Executing'],\n      GET_PRICE :this.state['GET_PRICE'],\n      GET_NEWS :this.state['GET_NEWS'],\n      PROCESS_PRICE :this.state['PROCESS_PRICE'],\n      PROCESS_NEWS :this.state['PROCESS_NEWS'],\n      PROCESS_REFLET :this.state['PROCESS_REFLET'],\n      MAKE_TRADE :this.state['MAKE_TRADE']\n    })\n  }\n}","import {\n    type ActionExample,\n    elizaLogger,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    type Action,\n    HandlerCallback,\n    MessageMemory,\n    EventType,\n    MemoryType,\n    logger,\n    asUUID,\n} from \"@elizaos/core\";\n\nimport { ApiService } from \"src/services/ApiService\";\n\nimport { z } from \"zod\";\n\nexport enum Blockchains {\n    BTC = \"btc\",\n    SOL = \"sol\",\n    ETH = \"eth\",\n}\n\nimport { v4 } from 'uuid';\n\nexport const getBlockchainPriceRequestSchema = z.object({\n  blockchain: z\n      .nativeEnum(Blockchains)\n      .describe(\"The blockchain to get statistics for\"),\n  date: z\n      .string()\n      .optional()\n      .describe(\"The date to request (optional)\"),\n  // toTimestamp: z\n  //     .number()\n  //     .optional()\n  //     .describe(\"End timestamp for the transfers (optional)\"),\n});\n\n/**\n * Validates the blockchain stats request\n */\n\nexport const getOnChainData: Action = {\n    name: \"GET_PRICE\",\n    similes: [\n        \"GET_PRICE\",\n        \"CHECK_PRICE\",\n        \"PRICE_CHECK\",\n        \"GET_CRYPTO_PRICE\",\n        \"CRYPTO_PRICE\",\n        \"CHECK_CRYPTO_PRICE\",\n        \"PRICE_LOOKUP\",\n    ],\n    description: \"Get current price information for a cryptocurrency pair\",\n    validate: async (runtime: IAgentRuntime, message: MessageMemory, state: State) => {\n        // return (state['stage'] && state['stage']=='GET_DATA');\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state:State,\n        _options:{[key:string]:unknown},\n        callback: HandlerCallback,\n        _responses: Memory[]\n    ): Promise<unknown> => {\n        try {\n            const service = runtime.getService(ApiService.serviceType) as ApiService;\n            /*\n            const resp = await service.postOnChianAPI(data.blockchain, data.date);\n            */\n            const resp = 'BTC price: {today:{24h Low/High $107,493.00 / $110,269.00}, yesterday:{24h Low/High $108,640.00 / $110,236.00}, }';\n            service.data['PRICE'] = resp;\n            if(callback){\n                callback({\n                    text:`\n                    Here is the on-chain data: \n                    \n                    ${resp}\n                    `\n                });\n            }\n            service.state['GET_PRICE'] = 'DONE';\n            service.state['Executing'] = true;\n            var message: Memory;\n            message.content.text = 'CryptoTrade_Action_GET_PRICE DONE';\n            message.id = asUUID(v4());\n            runtime.emitEvent(EventType.MESSAGE_SENT, {runtime: runtime, message: message, source: 'CryptoTrade_Action_GET_PRICE'});\n            logger.warn('***** ACTION GET_PRICE DONE *****')\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in price check:\", error);\n            if(callback){\n                callback({\n                    text:`\n                    Error in price check:\n                    \n                    ${error.message}\n                    `\n                });\n                return false;\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                name: \"{{user1}}\",\n                content: {\n                    text: \"What's the market price of Bitcoin yesterday?\",\n                },\n            },\n            {\n                name: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the Bitcoin market price for you right away.\",\n                    action: \"GET_PRICE\",\n                },\n            },\n            {\n                name: \"{{agent}}\",\n                content: {\n                    text: \"The current BTC market price is {date}, open: {open price} USDT, close: {close price}} USDT\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you check ETH price on 2025/04/03?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the Ethereum price on 2025/04/03 for you.\",\n                    action: \"GET_PRICE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"The ETH price on 2025/04/03 is {date}, open: {open price} USDT, close: {close price}} USDT\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","import {\n    type ActionExample,\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State, \n    type Action,\n    MessageMemory,\n    EventType,\n    logger,\n    asUUID,\n} from \"@elizaos/core\";\n// import {CRYPTO_EventType} from '../index.ts'\nimport {v4} from 'uuid';\nimport { ApiService } from \"src/services/ApiService\";\nexport const processNewsData: Action = {\n    name: \"PROCESS_NEWS\",\n    similes: [\n        \"ANALYZE_NEWS\"\n    ],\n    description: \"Analyze news and make a cryptocurrency trade\",\n    validate: async (runtime: IAgentRuntime, message: MessageMemory, state: State) => {\n        // return (state['stage'] && state['stage']=='GET_DATA');\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state:State,\n        _options:{[key:string]:unknown},\n        callback: HandlerCallback,\n        _responses: Memory[]\n    ): Promise<boolean> => {\n        try {\n            // var result = getBlockchainPriceRequestSchema.safeParse(message.content);\n            // if (!result.success) {\n            //     throw new ValidationError(result.error.message);\n            // }\n            // var data = getBlockchainPriceRequestSchema.parse(message.content);\n            // // Ensure the content has the required shape\n            // const content = {\n            //     symbol: data.blockchain.toString().toUpperCase().trim(),\n            // };\n            // if (content.symbol.length < 2 || content.symbol.length > 10) {\n            //     throw new Error(\"Invalid cryptocurrency symbol\");\n            // }\n            const service = runtime.getService(ApiService.serviceType) as ApiService;\n            // const resp = await service.postNewsAPI(data.blockchain, data.date);\n            const resp = 'Analysis done, the news shows that the price of the cryptocurrency will go down.';\n            if(callback){\n                callback({\n                    text:`\n                    Here is the analysis of off-chain news: \n                    \n                    ${resp}\n                    `\n                });\n            }\n            service.data['ANALYSIS_NEWS'] = resp;\n            service.state['PROCESS_NEWS'] = 'DONE';\n            var message: Memory;\n            message.content.text = 'CryptoTrade_Action_PROCESS_NEWS DONE';\n            message.id = asUUID(v4());\n            runtime.emitEvent(EventType.MESSAGE_SENT, {runtime: runtime, message:message, source: 'CryptoTrade_Action_PROCESS_NEWS'});\n            logger.warn('***** ACTION PROCESS_NEWS DONE *****')\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in news analyse:\", error);\n            if(callback){\n                callback({\n                    text:`\n                    Error in news analyze:\n                    \n                    ${error.message}\n                    `\n                });\n                return false;\n            }\n            return false;\n        }\n    },\n    examples: [\n    ] as ActionExample[][],\n} as Action;\n\n","import {\n    type ActionExample,\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State, \n    type Action,\n    MessageMemory,\n    EventType,\n    logger,\n    asUUID,\n} from \"@elizaos/core\";\n// import {CRYPTO_EventType} from '../index.ts'\nimport {v4} from 'uuid';\nimport { ApiService } from \"src/services/ApiService\";\nexport const processPriceData: Action = {\n    name: \"PROCESS_PRICE\",\n    similes: [\n        \"ANALYZE_PRICE\"\n    ],\n    description: \"Analyze price and make a cryptocurrency trade\",\n    validate: async (runtime: IAgentRuntime, message: MessageMemory, state: State) => {\n        // return (state['stage'] && state['stage']=='GET_DATA');\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state:State,\n        _options:{[key:string]:unknown},\n        callback: HandlerCallback,\n        _responses: Memory[]\n    ): Promise<boolean> => {\n        try {\n            const service = runtime.getService(ApiService.serviceType) as ApiService;\n            /**\n            const prompt = composePromptFromState({\n                    state,\n                    template: 'You are a crypto trader, analyze the data below, and feedback a report: ' + data;\n                });\n            }\n            const resp = await runtime.useModel(ModelType.TEXT_LARGE, {\n                prompt: prompt,\n            });\n             */\n            const resp = 'Analysis done, it seems that the price will go down.';\n            if(callback){\n                callback({\n                    text:`\n                    Here is the analysis of on-chain data: \n                    \n                    ${resp}\n                    `\n                });\n            }\n            service.data['ANALYSIS_PRICE'] = resp;\n            service.state['PROCESS_PRICE'] = 'DONE';\n            var message: Memory;\n            message.content.text = 'CryptoTrade_Action_PROCESS_PRICE DONE';\n            message.id = asUUID(v4());\n            runtime.emitEvent(EventType.MESSAGE_SENT, {runtime: runtime, message:message, source: 'CryptoTrade_Action_PROCESS_PRICE'});\n            logger.warn('***** ACTION PROCESS_PRICE DONE *****')\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in price analyse:\", error);\n            if(callback){\n                callback({\n                    text:`\n                    Error in news analyze:\n                    \n                    ${error.message}\n                    `\n                });\n                return false;\n            }\n            return false;\n        }\n    },\n    examples: [\n    ] as ActionExample[][],\n} as Action;\n\n","import {\n  type Action,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n} from '@elizaos/core';\n\nimport { z } from \"zod\";\nimport { ModelType } from \"@elizaos/core/v2\";\nimport { ApiService } from 'src/services/ApiService';\n\nexport const getBlockchainPriceRequestSchema = z.object({\n  blockchain: z\n      .nativeEnum({BTC:\"btc\", SOL: \"sol\", ETH:\"eth\"})\n      .describe(\"The blockchain to get statistics for\"),\n  date: z\n      .string()\n      .optional()\n      .describe(\"The date to request (optional)\"),\n  // toTimestamp: z\n  //     .number()\n  //     .optional()\n  //     .describe(\"End timestamp for the transfers (optional)\"),\n});\n\nconst replyTemplate = `# Task: Generate dialog for user.\n# Instructions: Write the next message for user.\n\"thought\" should be a short description of what the agent is thinking about and planning.\n\"message\" should be the next message for user which they will send to the conversation.\n\"action\" should be the next action that agent will conduct. \nRULE 1: User is asking the price of BTC, then the \"action\" will be GET_PRICE; \nRULE 2: User wants to know news of ETH, the \"action\" in reply should be \"GET_NEWS\"; \nRULE 3: User is talking about other things, set \"action\" as \"NONE\".\n\nResponse format should be formatted in a valid JSON block like this:\n\\`\\`\\`json\n{\n    \"thought\": \"<string>\",\n    \"message\": \"<string>\",\n    \"action\": \"<string>\",\n}\n\\`\\`\\`\n\nYour response should include the valid JSON block and nothing else.`;\n\nexport const reply: Action = {\n    name: \"REPLY\",\n    similes: [\n        \"REPLY_TO_MESSAGE\",\n        \"RESPNES\",\n        \"RESPOND\"\n    ],\n    description: \"Generate first response to user.\",\n    validate: async (_runtime: IAgentRuntime, _message: Memory, _state: State): Promise<boolean> => {\n        // Always valid\n        return true;\n    },\n\n  handler: async (\n    _runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: any,\n    callback: HandlerCallback,\n    _responses: Memory[]\n  ) => {\n    try {\n        logger.info('Handling reply action');\n        const service = _runtime.getService(ApiService.serviceType) as ApiService;\n        const responseContent = {\n            thought: '',\n            // text: 'The final decision of trade in step[' + (service.data['STEP']-1) + '] is: ' + service.record[(service.data['STEP']-1)]['TRADE'] + '\\n',\n            text: 'The final decision of trade is sell [-0.3/1.0]\\n',\n            actions: ['REPLY'],\n        };      \n        service.state['Executing'] = false;\n        service.stepEnd();\n      // Call back with the hello world message\n      await callback(responseContent);\n    } catch (error) {\n      logger.error('Error in REPLY action:', error);\n      throw error;\n    }\n  },\n  examples: [],\n};\n","import {\n    type ActionExample,\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State, \n    type Action,\n    MessageMemory,\n    EventType,\n    logger,\n    asUUID,\n} from \"@elizaos/core\";\n// import {CRYPTO_EventType} from '../index.ts'\nimport {v4} from 'uuid';\nimport { ApiService } from \"src/services/ApiService\";\nexport const makeTrade: Action = {\n    name: \"MAKE_TRADE\",\n    similes: [\n        \"MAKE_DECISION\"\n    ],\n    description: \"Make a cryptocurrency trade\",\n    validate: async (runtime: IAgentRuntime, message: MessageMemory, state: State) => {\n        // return (state['stage'] && state['stage']=='GET_DATA');\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state:State,\n        _options:{[key:string]:unknown},\n        callback: HandlerCallback,\n        _responses: Memory[]\n    ): Promise<boolean> => {\n        try {\n            // var result = getBlockchainPriceRequestSchema.safeParse(message.content);\n            // if (!result.success) {\n            //     throw new ValidationError(result.error.message);\n            // }\n            // var data = getBlockchainPriceRequestSchema.parse(message.content);\n            // // Ensure the content has the required shape\n            // const content = {\n            //     symbol: data.blockchain.toString().toUpperCase().trim(),\n            // };\n            // if (content.symbol.length < 2 || content.symbol.length > 10) {\n            //     throw new Error(\"Invalid cryptocurrency symbol\");\n            // }\n            const service = runtime.getService(ApiService.serviceType) as ApiService;\n            // const resp = await service.postNewsAPI(data.blockchain, data.date);\n            const resp = 'After check and analyze the price and news of the cryptocurrency, I think we should sell 30% of it. My trade decision is -0.3/1.0';\n            if(callback){\n                callback({\n                    text:`\n                    Here is the analysis of on-chain data: \n                    \n                    ${resp}\n                    `\n                });\n                        \n                // await runtime.emitEvent(CRYPTO_EventType.CRYPTO_NOTIFY_ACTION_END, {\n                //     runtime,\n                //     entityId: runtime.agentId,\n                //     status: 'CRYPTO_NOTIFY_ACTION_END',\n                //     source: runtime.character.name,\n                // });\n                // state['stage']='NOTIFY_MANAGER';\n                \n                service.state['MAKE_TRADE'] = 'DONE';\n                service.data['TRADE'] = resp;\n                var message: Memory;\n                message.content.text = 'CryptoTrade_Action_MAKE_TRADE DONE';\n                message.id = asUUID(v4());\n                runtime.emitEvent(EventType.MESSAGE_SENT, {runtime: runtime, message:message, source: 'CryptoTrade_Action_MAKE_TRADE'});\n                logger.warn('***** ACTION MAKE_TRADE DONE *****')\n                return true;\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error in MAKE_TRADE:\", error);\n            if(callback){\n                callback({\n                    text:`\n                    Error in news analyze:\n                    \n                    ${error.message}\n                    `\n                });\n                return false;\n            }\n            return false;\n        }\n    },\n    examples: [\n    ],\n} as Action;\n\n"],"mappings":"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","names":["Service","logger","asUUID","z","logger","data","logger","elizaLogger","EventType","logger","asUUID","Blockchains","asUUID","EventType","logger","elizaLogger","elizaLogger","EventType","logger","asUUID","asUUID","EventType","logger","elizaLogger","elizaLogger","EventType","logger","asUUID","asUUID","EventType","logger","elizaLogger","logger","z","getBlockchainPriceRequestSchema","z","logger","composePromptFromState","EventType","elizaLogger","EventType","logger","asUUID","asUUID","EventType","logger","elizaLogger","z","logger","Service","asUUID","composePromptFromState","EventType","logger","z"]}